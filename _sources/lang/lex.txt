Lexical Structure
=================

This chapter specifies the lexical structure of the Tart language.

Unicode
-------

Programs are written using the Unicode character set. Information about
this character set and its associated character encodings may be found at:

  http://www.unicode.org

The current implementation of the compiler recognizes programs written in
UTF-8, however support for other Unicode encodings is planned. Internally
strings are encoded as UTF-8 byte sequences, although there are APIs to
access characters as 32-bit values, as well as a variety of methods for
encoding and decoding strings in other character encodings.

Line Terminators
----------------

A Tart source file consists of a sequence of lines, each of which consists
of zero or more characters terminated by an end-of-line sequence. In source
files, any of the standard platform line termination sequences can be
used - the Unix form using ASCII LF (linefeed), the Windows form using
the ASCII sequence CR LF (return followed by linefeed), or the old Macintosh
form using the ASCII CR (return) character. All of these forms can be
used equally, regardless of platform.

Tart is a "free-form" language, meaning that line separators are
considered the same as other whitespace. The one exception to this rule
is the "//" comment form, which is terminated by an end-of-line
sequence.

Input Elements and Tokens
-------------------------

White Space
-----------

Comments
--------

Tart comments are similar to those seen in C++ and Java::

  /* A block comment. */
  // A line comment

In addition, Tart supports two forms of 'tartdoc' comments which can be used to
automatically generate documentation:

  /** A tartdoc block comment. */
  /// A tartdoc line comment.

Tart supports a lightweight form of markup within comments that can be used to
call out parameters and return values. Here's an example::

  /** Collect all type definitions in the AST.
      Parameters:
        defn - where to put the definitions.
        recurse - whether to search recursively.
      Returns:
        The number of definitions found.
  */

The doc comment markup language is designed to minimize the impact on the
readability of comments in the source code. This will be explained in
greater detail in a later section. [TODO: link]

Identifiers
-----------

Keywords
--------

The list of Tart keywords::

    abstract   classify   finally    interface  null       set        switch     uint8
    and        const      float      internal   or         short      throw      ulong
    as         constable  fn         is         override   sint16     true       undef
    bool       continue   for        isa        private    sint32     try        using
    break      def        friend     let        protected  sint64     typecast   var
    byte       double     get        long       protocol   sint8      ubyte      void
    case       else       if         macro      public     static     uint       where
    catch      enum       import     mutable    readonly   struct     uint16     while
    char       false      in         namespace  repeat     short      uint32     yield
    class      final      int        not        return     super      uint64

Literals
--------

.. productionlist::
  literal: `int_lit` | `float_lit` | `string_lit` | `char_lit` | `null_lit` | `array_lit` | `type_lit`
  int_lit: [0-9_]+
  float_lit: [0-9_](.[0-9_]+)?(e[0-9_]+)
  string_lit: '"' chars '"'
  char_lit: "'" chars "'"
  bool_lit: "true" | "false"
  null_lit: "null"
  array_lit: "[" [`expression` ("," `expression`)*] "]"
  type_lit: typeof `type_expression`

Integer Literals
^^^^^^^^^^^^^^^^

An integer literal starts with a digit, and may contain any number of digits.
Integer literals may also contain underscores, which can be used as a thousands
separator - for example, the number one million can be written either as
``1000000`` or as ``1_000_000``. The underscores are purely decorative, and
have no affect upon the value of the integer.

Integer literals are typeless by default, meaning that they have no specified
bit size and can be arbitrarily large. The size of the integer is set once the
integer is assigned to a variable, or typecast to a specific integer type. A
check is done to insure that the literal value will fit in the desired space.
This means that calculations with integer literals can have intermediate
results that are larger than the destination size, as long as the final
result of the calculation will fit::

  var i:int8 = 1_000_001 - 1_000_000;

Even though a value of one million cannot fit into an 8-bit integer, there is
no problem here, because the subtraction yields a value of 1, which will fit.

Floating-Point Literals
^^^^^^^^^^^^^^^^^^^^^^^

A floating-point literals starts with a digit or a point, and must contain
either a point or an exponent (signified with the letter 'e') in order to
distinguish it from an integer. The floating-point literal may also contain
underscore characters, similar to integers.

Unlike integers, floating-point literals have distinct sizes, which are
``float`` (32-bits), ``double`` (64 bits) and ``long double`` which is
somewhere between 80 and 128 bits, depending on the capabilities of the
processor.

Boolean Literals
^^^^^^^^^^^^^^^^

The boolean literals are ``true`` and ``false``.

Character and String Literals
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Escape Sequences for Character and String Literals
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Array Literals
^^^^^^^^^^^^^^

The Null Literal
^^^^^^^^^^^^^^^^

Separators
----------

Operators
---------
