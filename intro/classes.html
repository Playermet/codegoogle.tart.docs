<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>User-defined types: Composites &mdash; Tart v0.1.1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.1',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Tart v0.1.1 documentation" href="../index.html" />
    <link rel="up" title="Introduction to Tart" href="index.html" />
    <link rel="next" title="Typecasts and conversions" href="conversions.html" />
    <link rel="prev" title="Function Type Expressions" href="functions.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="conversions.html" title="Typecasts and conversions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="functions.html" title="Function Type Expressions"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Tart v0.1.1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Introduction to Tart</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="user-defined-types-composites">
<span id="index-828"></span><h1>User-defined types: Composites<a class="headerlink" href="#user-defined-types-composites" title="Permalink to this headline">¶</a></h1>
<p>The <tt class="xref docutils literal"><span class="pre">class</span></tt> keyword is one of the four keywords that are used to define a new
aggregate type. The others are <tt class="xref docutils literal"><span class="pre">struct</span></tt>, <tt class="xref docutils literal"><span class="pre">interface</span></tt> and <tt class="xref docutils literal"><span class="pre">protocol</span></tt>.</p>
<ul>
<li><p class="first">A <tt class="xref docutils literal"><span class="pre">class</span></tt> is <em>reference</em> type, meaning it is always passed around by reference.
When a value of class type is assigned to a variable, all that gets copied is a pointer to
the object, not the object&#8217;s contents.</p>
</li>
<li><p class="first">A <tt class="xref docutils literal"><span class="pre">struct</span></tt> is a <em>value</em> type. That means that normally when you assign one struct
variable to another, it does a member-wise copy of the entire thing.</p>
</li>
<li><p class="first">An <tt class="xref docutils literal"><span class="pre">interface</span></tt> defines an pure abstract type which can only contain methods, types
and constants. Like Java and C#, Tart does not support multiple inheritance, but does allow
classes to derive from multiple interfaces. See the section on <a class="reference internal" href="#interfaces"><em>Interfaces</em></a>.</p>
</li>
<li><p class="first">A <tt class="xref docutils literal"><span class="pre">protocol</span></tt> represents a contract which a type may conform to. A class or struct
is said to <em>support</em> the protocol if that class or struct defines all of the method signatures
that are defined by the protocol. Template arguments can be constrained to only match types
which support a specified protocol. Classes may declare explicitly that they support a protocol,
or the support can be determined implicitly.</p>
<p>Protocols will be discussed further in the section on <a class="reference internal" href="#protocols"><em>Protocols</em></a>.</p>
</li>
</ul>
<div class="section" id="declaring-a-new-class">
<span id="index-829"></span><h2>Declaring a new class<a class="headerlink" href="#declaring-a-new-class" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="xref docutils literal"><span class="pre">class</span></tt> keyword defines a new class. Here is a sample of a class definition:</p>
<div class="highlight-tart"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">// Declare a class. The base class is &#39;ListNode&#39;.</span>
<span class="k">class</span> <span class="nc">Shape</span> <span class="p">:</span> <span class="nc">ListNode</span> <span class="k">{</span>
  <span class="c">// Declare an enumeration</span>
  <span class="k">enum</span> <span class="nc">Style</span> <span class="k">{</span>
    <span class="nv">Filled</span><span class="p">,</span>
    <span class="nv">Hollow</span><span class="p">,</span>
  <span class="k">}</span>

  <span class="c">// Private member variables.</span>
  <span class="k">private</span> <span class="k">{</span>
    <span class="c">// Allow the unit test access to these vars.</span>
    <span class="k">friend</span> <span class="nc">ShapeTest</span><span class="p">;</span>

    <span class="c">// Some variables.</span>
    <span class="k">var</span> <span class="nv">fillStyle</span><span class="p">:</span><span class="nc">Style</span> <span class="o">=</span> <span class="nv">Style</span><span class="o">.</span><span class="nv">Filled</span><span class="p">;</span>
    <span class="k">var</span> <span class="nv">fillColor</span><span class="p">:</span><span class="nc">Color</span><span class="p">;</span>

    <span class="c">// A variable with parameterized type.</span>
    <span class="k">var</span> <span class="nv">children</span><span class="p">:</span><span class="nc">List</span><span class="p">[</span><span class="nv">Shape</span><span class="p">];</span>
  <span class="k">}</span>

  <span class="c">// A member function.</span>
  <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="nv">dc</span><span class="p">:</span><span class="nc">DrawContext</span><span class="p">)</span> <span class="k">{</span>
    <span class="nv">dc</span><span class="o">.</span><span class="nv">setFillStyle</span><span class="p">(</span><span class="nv">fillStyle</span><span class="p">);</span>
    <span class="k">for</span> <span class="nv">child</span> <span class="k">in</span> <span class="nv">children</span> <span class="k">{</span>
      <span class="nv">child</span><span class="o">.</span><span class="nv">draw</span><span class="p">(</span><span class="nv">dc</span><span class="p">);</span>
    <span class="k">}</span>
  <span class="k">}</span>

  <span class="c">// A method with variable number of arguments</span>
  <span class="c">// The &#39;children&#39; argument&#39;s actual type is Shape[]</span>
  <span class="nv">final</span> <span class="k">def</span> <span class="nf">addChildren</span><span class="p">(</span><span class="nv">children</span><span class="p">:</span><span class="nc">Shape</span><span class="gr">...</span><span class="p">)</span> <span class="k">{</span>
    <span class="c">// Explicitly qualified self.children to disambiguate</span>
    <span class="c">// from same-named parameter.</span>
    <span class="bp">self</span><span class="o">.</span><span class="nv">children</span><span class="o">.</span><span class="nv">extend</span><span class="p">(</span><span class="nv">children</span><span class="p">);</span>
  <span class="k">}</span>
<span class="k">}</span>
</pre></div>
</td></tr></table></div>
<p>A couple of things are worth noticing in this example:</p>
<p><strong>Dynamic dispatch is the default</strong>: Like most object-oriented languages (other than C++), all
functions are dynamically overridable (<tt class="docutils literal"><span class="pre">virtual</span></tt> in C++ parlance) unless declared <tt class="docutils literal"><span class="pre">final</span></tt>.</p>
<p><strong>Private members:</strong> You can declare a block of variables as <tt class="xref docutils literal"><span class="pre">private</span></tt>, rather than having
to put the word <tt class="xref docutils literal"><span class="pre">private</span></tt> in front of every variable name. Within a <tt class="xref docutils literal"><span class="pre">private</span></tt> or
<tt class="xref docutils literal"><span class="pre">protected</span></tt> block, you can declare <tt class="xref docutils literal"><span class="pre">friend</span></tt> classes that have direct access to
just these class members.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The last point deserves some additional explanation: With C++, you can
only declare a <tt class="xref docutils literal"><span class="pre">friend</span></tt> of an entire class. In Java, you can&#8217;t declare a
<tt class="xref docutils literal"><span class="pre">friend</span></tt> at all. Both of these feature choices cause programmers to expose
too much encapsulated data. In the case of C++, you can&#8217;t expose a private
member without exposing everything. In Java, not having the ability to
expose private data to certain classes causes Java programmers to declare
class members <tt class="docutils literal"><span class="pre">public</span></tt> far more than the would otherwise.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><tt class="docutils literal"><span class="pre">friend</span></tt> is not implemented in the current release.</p>
</div>
</div>
<div class="section" id="defining-class-members">
<span id="index-830"></span><h2>Defining class members<a class="headerlink" href="#defining-class-members" title="Permalink to this headline">¶</a></h2>
<p>There is no restriction on the kinds of declarations which can appear in the body of a
<tt class="xref docutils literal"><span class="pre">class</span></tt> or <tt class="xref docutils literal"><span class="pre">struct</span></tt>, but most commonly they will be variable or method
declarations.</p>
<div class="section" id="member-visibility">
<span id="index-831"></span><h3>Member Visibility<a class="headerlink" href="#member-visibility" title="Permalink to this headline">¶</a></h3>
<p>A member definition can have one of three visibility levels:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">public</span></tt>, which is visible from everywhere;</li>
<li><tt class="docutils literal"><span class="pre">protected</span></tt>, which is visible only within the body of the class and its subclasses.</li>
<li><tt class="docutils literal"><span class="pre">private</span></tt>, which is visible only within the body of the class itself.</li>
</ul>
</blockquote>
</div>
<div class="section" id="member-variables">
<span id="index-832"></span><h3>Member Variables<a class="headerlink" href="#member-variables" title="Permalink to this headline">¶</a></h3>
<p>A variable declared within a class body is a class instance variable, unless it the
<tt class="docutils literal"><span class="pre">static</span></tt> modifier is present, in which case it is a static variable.</p>
<p>Variable declarations can include an optional initialization expression. If present, the
variable will be initialized to this value when the class instance is created, instead of
the built-in default for that type.</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Point</span> <span class="k">{</span>
  <span class="k">var</span> <span class="nv">x</span><span class="p">:</span><span class="kt">int</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
  <span class="k">var</span> <span class="nv">y</span><span class="p">:</span><span class="kt">int</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
<span class="k">}</span>
</pre></div>
</div>
<p>Variables may be defined with either <tt class="xref docutils literal"><span class="pre">let</span></tt> or <tt class="xref docutils literal"><span class="pre">var</span></tt>. Variables defined with <tt class="xref docutils literal"><span class="pre">let</span></tt>
are constant, and may not be changed once initialized.</p>
</div>
<div class="section" id="properties">
<span id="index-833"></span><h3>Properties<a class="headerlink" href="#properties" title="Permalink to this headline">¶</a></h3>
<p>A <em>property</em> is a member definition that has a <em>getter</em> and <em>setter</em> function, and is otherwise
accessed like a variable. Reading from the property calls the getter function, and writing to
it calls the setter function. It is not required that both the getter and setter be defined,
although at least one of them must be.</p>
<p>Properties are defined with the <tt class="xref docutils literal"><span class="pre">def</span></tt> keyword, followed by a colon and the type of the
property:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Rectangle</span> <span class="k">{</span>
  <span class="c">// Some member variables</span>
  <span class="k">var</span> <span class="nv">left</span><span class="p">:</span><span class="kt">int</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
  <span class="k">var</span> <span class="nv">top</span><span class="p">:</span><span class="kt">int</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
  <span class="k">var</span> <span class="nv">right</span><span class="p">:</span><span class="kt">int</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
  <span class="k">var</span> <span class="nv">bottom</span><span class="p">:</span><span class="kt">int</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>

  <span class="c">// Width property</span>
  <span class="k">def</span> <span class="nf">width</span><span class="p">:</span><span class="kt">int</span> <span class="k">{</span>
    <span class="k">get</span> <span class="k">{</span> <span class="k">return</span> <span class="nv">right</span> <span class="o">-</span> <span class="nv">left</span><span class="p">;</span> <span class="k">}</span>
    <span class="k">set</span> <span class="k">{</span> <span class="nv">right</span> <span class="o">=</span> <span class="nv">left</span> <span class="o">+</span> <span class="nv">value</span><span class="p">;</span> <span class="k">}</span>
  <span class="k">}</span>

  <span class="c">// Height property</span>
  <span class="k">def</span> <span class="nf">height</span><span class="p">:</span><span class="kt">int</span> <span class="k">{</span>
    <span class="k">get</span> <span class="k">{</span> <span class="k">return</span> <span class="nv">bottom</span> <span class="o">-</span> <span class="nv">top</span><span class="p">;</span> <span class="k">}</span>
    <span class="k">set</span> <span class="k">{</span> <span class="nv">bottom</span> <span class="o">=</span> <span class="nv">top</span> <span class="o">+</span> <span class="nv">value</span><span class="p">;</span> <span class="k">}</span>
  <span class="k">}</span>
<span class="k">}</span>

<span class="nv">r</span> <span class="o">=</span> <span class="nv">Rectangle</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="mf">10</span><span class="p">,</span> <span class="mf">10</span><span class="p">);</span>

<span class="c">// Calls the getter method of the rectangle&#39;s &#39;width&#39; property</span>
<span class="k">let</span> <span class="nv">w</span> <span class="o">=</span> <span class="nv">r</span><span class="o">.</span><span class="nv">width</span><span class="p">;</span>

<span class="c">// Calls the setter method of the rectangle&#39;s &#39;height&#39; property</span>
<span class="nv">r</span><span class="o">.</span><span class="nv">height</span> <span class="o">=</span> <span class="mf">3</span><span class="p">;</span>
</pre></div>
</div>
<p>In the example above, we define two properties <tt class="docutils literal"><span class="pre">width</span></tt> and <tt class="docutils literal"><span class="pre">height</span></tt> which are synthesized
from the coordinates of the rectangle. In the case of the <tt class="docutils literal"><span class="pre">get</span></tt> method, the return statement
returns the value of the property.</p>
<p>For <tt class="docutils literal"><span class="pre">set</span></tt> methods, the implicit pseudo-variable <tt class="docutils literal"><span class="pre">value</span></tt> contains the value being assigned
to the property.</p>
</div>
<div class="section" id="methods">
<span id="index-834"></span><h3>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h3>
<p>In Tart, the term <em>Method</em> and <em>Function</em> are interchangeable - usually &#8220;Function&#8221; is used
when speaking of global functions, and &#8220;Method&#8221; when speaking of member functions.</p>
<p>The <tt class="xref docutils literal"><span class="pre">def</span></tt> keyword defines a new method, as previously describe in the section on
<a class="reference external" href="declarations.html#functiondeclarations"><em>Function Declarations</em></a>.</p>
<p>Methods defined in a class are automatically inherited by subclasses of that class. An
inherited method definition can be overridden using the <tt class="xref docutils literal"><span class="pre">override</span></tt> keyword. The subclass
method definition must have the same name and type signature as the base class method
being overridden:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Base</span> <span class="k">{</span>
  <span class="k">def</span> <span class="nf">doAction</span><span class="p">(</span><span class="nv">code</span><span class="p">:</span><span class="nc">ActionCode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">ResultCode</span> <span class="k">{</span>
    <span class="c">// Base class definition</span>
  <span class="k">}</span>
<span class="k">}</span>

<span class="k">class</span> <span class="nc">Subclass</span> <span class="p">:</span> <span class="nc">Base</span> <span class="k">{</span>
  <span class="k">override</span> <span class="nv">doAction</span><span class="p">(</span><span class="nv">code</span><span class="p">:</span><span class="nv">ActionCode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nv">ResultCode</span> <span class="k">{</span>
    <span class="c">// Subclass definition</span>
  <span class="k">}</span>
<span class="k">}</span>
</pre></div>
</div>
<p>The <tt class="xref docutils literal"><span class="pre">def</span></tt> keyword cannot be used to override a base class method - it is an error
to use <tt class="xref docutils literal"><span class="pre">def</span></tt> to define a method with the same name and type signature as a method
in a base class.</p>
<p>The <tt class="xref docutils literal"><span class="pre">override</span></tt> keyword is only required when overriding methods defined in a base class.
It is <em>not</em> required (and is not allowed) when implementing a method defined in an interface.
(Implementing an interface is not considered &#8220;inheritance&#8221;.)</p>
<p>Methods overridden using <tt class="xref docutils literal"><span class="pre">override</span></tt> use dynamic dispatching, much like the way
virtual functions work in C++. The decision of which method body gets executed when a method
gets called is based on the real type of the object, not it&#8217;s declared type at that point
in the code.</p>
<p id="index-835">An inherited method definition can also be <em>undefined</em> using the <tt class="xref docutils literal"><span class="pre">undef</span></tt> keyword.
An undefined method simply throws an <tt class="xref docutils literal"><span class="pre">UnsupportedOperationError</span></tt> exception, and
is a convenient way to signal that a subclass does not support an operation that is defined
in the base class:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Base</span> <span class="k">{</span>
  <span class="k">def</span> <span class="nf">caption</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">{</span>
    <span class="k">return</span> <span class="s">&quot;Howdy!&quot;</span><span class="p">;</span>
  <span class="k">}</span>
<span class="k">}</span>

<span class="k">class</span> <span class="nc">Subclass</span> <span class="p">:</span> <span class="nc">Base</span> <span class="k">{</span>
  <span class="nv">undef</span> <span class="nv">caption</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">;</span>
<span class="k">}</span>
</pre></div>
</div>
<p>Unlike <tt class="xref docutils literal"><span class="pre">override</span></tt>, <tt class="xref docutils literal"><span class="pre">undef</span></tt> works with methods defined in interfaces as well as base
classes. There is an additional use
for <tt class="xref docutils literal"><span class="pre">undef</span></tt>, which is to suppress the creation of implicit methods which would be added by the
compiler, such as the default constructor. For example, suppose there is some data type which
is never intended to be constructed within Tart code, but only created by some external C
library:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">struct</span> <span class="nc">TimeStamp</span> <span class="k">{</span>
  <span class="k">var</span> <span class="nv">value</span><span class="p">:</span><span class="nc">uint64</span><span class="p">;</span>

  <span class="c">// Tell the compiler not to generate a default constructor.</span>
  <span class="nv">undef</span> <span class="nv">construct</span><span class="p">;</span>
<span class="k">}</span>
</pre></div>
</div>
<p id="index-836">A method may be declared <tt class="xref docutils literal"><span class="pre">final</span></tt>, informing the compiler that it is not permitted to
override that method in subclasses. This will in some cases allow the compiler to make additional
optimizations, avoiding the need for a dynamic dispatch:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Circle</span> <span class="k">{</span>
  <span class="nv">final</span> <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="nv">dc</span><span class="p">:</span><span class="nc">DrawContext</span><span class="p">)</span> <span class="k">{</span>
    <span class="c">// Code to draw a circle</span>
  <span class="k">}</span>
<span class="k">}</span>
</pre></div>
</div>
<p>The <tt class="xref docutils literal"><span class="pre">final</span></tt> keyword can also be applied to an entire class, which means that the class
cannot be subclassed at all.</p>
<p id="index-837">A method declared as <tt class="xref docutils literal"><span class="pre">abstract</span></tt> has no method body. A class containing an abstract method
must also be declared abstract:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Shape</span> <span class="k">{</span>
  <span class="k">abstract</span> <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="nv">dc</span><span class="p">:</span><span class="nc">DrawContext</span><span class="p">);</span>
<span class="k">}</span>
</pre></div>
</div>
<p>Abstract classes cannot be directly instantiated, only subclasses of the abstract class can be
instantiated, and only if those subclasses are themselves concrete (i.e. not abstract).
A concrete subclass of an abstract class must provide concrete definitions for all of the
inherited abstract methods.</p>
</div>
<div class="section" id="the-self-parameter">
<span id="index-838"></span><h3>The <tt class="docutils literal"><span class="pre">self</span></tt> parameter<a class="headerlink" href="#the-self-parameter" title="Permalink to this headline">¶</a></h3>
<p>Within a class method, the special variable <tt class="xref docutils literal"><span class="pre">self</span></tt> refers to the current instance.
You do not need to declare the  <tt class="xref docutils literal"><span class="pre">self</span></tt> variable explicitly.</p>
<p>Instance variables can be referred to directly by name, you do not need to qualify them
with <tt class="xref docutils literal"><span class="pre">self</span></tt> unless you also have a local variable or parameter with the same name.
<tt class="xref docutils literal"><span class="pre">self</span></tt> is often used in constructors:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span><span class="kt">int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span><span class="kt">int</span><span class="p">)</span> <span class="k">{</span>
  <span class="bp">self</span><span class="o">.</span><span class="nv">x</span> <span class="o">=</span> <span class="nv">x</span><span class="p">;</span>
  <span class="bp">self</span><span class="o">.</span><span class="nv">y</span> <span class="o">=</span> <span class="nv">y</span><span class="p">;</span>
<span class="k">}</span>
</pre></div>
</div>
<p>In most cases the <tt class="xref docutils literal"><span class="pre">self</span></tt> parameter works exactly like other, explicitly declared
parameters. The exception to this rule is the <tt class="xref docutils literal"><span class="pre">self</span></tt> parameter of <tt class="xref docutils literal"><span class="pre">struct</span></tt> methods.
Normally when the type of a function parameter is a <tt class="xref docutils literal"><span class="pre">struct</span></tt> type, the value that is
passed to that function is
a <em>copy</em> of the struct, however in the case of <tt class="xref docutils literal"><span class="pre">self</span></tt>, what gets passed is a <em>pointer</em> to
the struct. If this were not true, it would be impossible to write methods that modify
struct members, since the method could only modify the temporary copy. Note, however,
that if you assign the <tt class="xref docutils literal"><span class="pre">self</span></tt> parameter to another variable, the variable will
still get a copy.</p>
</div>
</div>
<div class="section" id="struct-members">
<span id="index-839"></span><h2>Struct members<a class="headerlink" href="#struct-members" title="Permalink to this headline">¶</a></h2>
<p>Method definitions in structs are always implicitly <tt class="xref docutils literal"><span class="pre">final</span></tt> and cannot be overridden.
The reason for  this is because structs do not have a hidden dispatch table like classes do,
so the decision of which method body gets executed has to be determined at compile time using
only the static type information at the calling site.</p>
</div>
<div class="section" id="creating-a-new-class-instance">
<span id="index-840"></span><h2>Creating a new class instance<a class="headerlink" href="#creating-a-new-class-instance" title="Permalink to this headline">¶</a></h2>
<p>The syntax for creating a new class instance is the same as in Python, which is
to call the class as if it were a function:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">var</span> <span class="nv">s</span> <span class="o">=</span> <span class="nv">Rectangle</span><span class="p">(</span><span class="mf">10</span><span class="p">,</span> <span class="mf">10</span><span class="p">,</span> <span class="mf">20</span><span class="p">,</span> <span class="mf">20</span><span class="p">);</span>
</pre></div>
</div>
<p>The creation syntax is the same regardless of whether an object is a value or reference type. If
it&#8217;s a value (<tt class="xref docutils literal"><span class="pre">struct</span></tt>) type, the new object will be constructed in place; If it&#8217;s a
reference (<tt class="xref docutils literal"><span class="pre">class</span></tt>) type, then space for the object will be allocated on the global heap,
and a pointer to the object assigned to the variable.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<div class="last compound">
<p class="compound-first">Value (<tt class="xref docutils literal"><span class="pre">struct</span></tt>) types can never exist on the heap except as instance variables
inside other, reference types. The reason for this is fairly involved, but the short explanation
is this: The garbage collector only deals with reference types. Every reference type has
a special, invisible header field that is used by the garbage collector to track the status
of the object. Structures, integers, floats, tuples, and other value types don&#8217;t have any
invisible fields, they are just &#8216;plain old data&#8217; or &#8216;POD&#8217; types.</p>
<p class="compound-last">Tart also restricts you from having long-lived pointers to these types, because there&#8217;s no
way to track the lifetime of these objects. If you need to keep a long-lived copy of a value
type around, it has to be wrapped inside another object. You can declare a value type as an
instance member of a class, or you can use the provided <tt class="xref docutils literal"><span class="pre">ValueRef</span></tt> or <tt class="xref docutils literal"><span class="pre">MutableRef</span></tt>
helper classes which will automatically wrap (&#8216;auto-box&#8217;) value types when needed.</p>
</div>
</div>
</div>
<div class="section" id="constructors">
<span id="index-841"></span><h2>Constructors<a class="headerlink" href="#constructors" title="Permalink to this headline">¶</a></h2>
<p>A <em>constructor method</em> is responsible for initializing the members of a class instance
when it is created. The constructor method is named <tt class="xref docutils literal"><span class="pre">construct()</span></tt>, and must not declare a
return value.</p>
<p>Here&#8217;s an example of a class with several constructors:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">struct</span> <span class="nc">Rectangle</span> <span class="k">{</span>
  <span class="k">var</span> <span class="nv">x</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
  <span class="k">var</span> <span class="nv">y</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
  <span class="k">var</span> <span class="nv">width</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
  <span class="k">var</span> <span class="nv">height</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>

  <span class="c">// Default constructor</span>
  <span class="k">def</span> <span class="nf">construct</span> <span class="k">{</span>
    <span class="nv">x</span> <span class="o">=</span> <span class="nv">y</span> <span class="o">=</span> <span class="nv">width</span> <span class="o">=</span> <span class="nv">height</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
  <span class="k">}</span>

  <span class="c">// Constructor that takes some arguments</span>
  <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span><span class="kt">int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span><span class="kt">int</span><span class="p">,</span> <span class="nv">width</span><span class="p">:</span><span class="kt">int</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span><span class="kt">int</span><span class="p">)</span> <span class="k">{</span>
    <span class="bp">self</span><span class="o">.</span><span class="nv">x</span> <span class="o">=</span> <span class="nv">x</span><span class="p">;</span>
    <span class="bp">self</span><span class="o">.</span><span class="nv">y</span> <span class="o">=</span> <span class="nv">y</span><span class="p">;</span>
    <span class="bp">self</span><span class="o">.</span><span class="nv">width</span> <span class="o">=</span> <span class="nv">width</span><span class="p">;</span>
    <span class="bp">self</span><span class="o">.</span><span class="nv">height</span> <span class="o">=</span> <span class="nv">height</span><span class="p">;</span>
  <span class="k">}</span>

  <span class="c">// Constructor that takes another Rectangle.</span>
  <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span><span class="nc">Rectangle</span><span class="p">)</span> <span class="k">{</span>
    <span class="nv">x</span> <span class="o">=</span> <span class="nv">from</span><span class="o">.</span><span class="nv">x</span><span class="p">;</span>
    <span class="nv">y</span> <span class="o">=</span> <span class="nv">from</span><span class="o">.</span><span class="nv">y</span><span class="p">;</span>
    <span class="nv">width</span> <span class="o">=</span> <span class="nv">from</span><span class="o">.</span><span class="nv">width</span><span class="p">;</span>
    <span class="nv">height</span> <span class="o">=</span> <span class="nv">from</span><span class="o">.</span><span class="nv">height</span><span class="p">;</span>
  <span class="k">}</span>
<span class="k">}</span>
</pre></div>
</div>
<p>When you create a new instance of a type by calling the type as a function, the compiler attempts to
locate a constructor method having the same signature as the calling arguments. This search
happens in several steps:</p>
<ul>
<li><p class="first">First, the compiler looks for a constructor method named <tt class="xref docutils literal"><span class="pre">construct()</span></tt> having the
appropriate signature.</p>
<p>If the class has one or more constructor methods, but none of them match the input arguments,
then the result is an error. Similarly, if there are constructors but none of them are accessible
to the caller, then this is also an error.</p>
</li>
<li><p class="first">If the class has no constructor methods at all, then the compiler will look for a static
member function called <tt class="xref docutils literal"><span class="pre">create()</span></tt> and call it instead.</p>
<p>The <tt class="xref docutils literal"><span class="pre">create()</span></tt> function is not required to return a newly created object every time - it
can return the same object as a previous call. It is also not required to return an object whose
type is the same as the class, but it should at least be a subtype.</p>
<p>The <tt class="xref docutils literal"><span class="pre">create()</span></tt> function is responsible for both allocating the memory for the object and
initializing it completely.</p>
<p>The <tt class="xref docutils literal"><span class="pre">create()</span></tt> function is often used to implement a custom allocation strategy for a type.
For example, the <tt class="xref docutils literal"><span class="pre">String</span></tt> class uses the <tt class="xref docutils literal"><span class="pre">create()</span></tt> function to allow string objects
to be variably sized - so that both the fixed-length header part and the variable-length
character array can be combined into a single memory allocation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is nothing special about this function other than the fact that the compiler
calls it automatically.</p>
</div>
</li>
<li><p class="first">If the class has no constructors, and no <tt class="xref docutils literal"><span class="pre">create()</span></tt> function, then the compiler will attempt
to synthesize a default constructor.</p>
</li>
</ul>
<p id="index-843">Any member variable which is not initialized by the constructor will be set to
its default value. If the default value for the member variable has not been
specified, then it uses the default value for that type.</p>
<div class="section" id="default-constructors">
<span id="index-844"></span><h3>Default constructors<a class="headerlink" href="#default-constructors" title="Permalink to this headline">¶</a></h3>
<p>If the object has no <tt class="xref docutils literal"><span class="pre">construct()</span></tt> method and no <tt class="xref docutils literal"><span class="pre">create()</span></tt> method, then the compiler
will attempt to create a default constructor. The default constructor takes no arguments,
and will initialize every field to its default value. If any fields cannot be initialized
to a default, then the compiler will emit an error.</p>
</div>
<div class="section" id="constructor-execution">
<span id="index-845"></span><h3>Constructor Execution<a class="headerlink" href="#constructor-execution" title="Permalink to this headline">¶</a></h3>
<p>The compiler will attempt to ensure that all member fields are initialized during the execution of
the constructor. Fields which have no defaults must be assigned in the constructor, whereas fields
which do have defaults (either explicitly specified or implicit based on the type) may not be.
If the compiler detects that any field is not fully initialized, then it will report an error.</p>
<p>Member variables that are declared with <tt class="xref docutils literal"><span class="pre">let</span></tt> cannot be assigned a value after the
constructor has finished execution. In most cases, these kinds of variables will be constants
anyway, meaning that their values are fixed at compile time. However, Tart also allows
<tt class="xref docutils literal"><span class="pre">let</span></tt> variables to be assigned in the constructor, in which case they are constant for
the life of that instance (similar to the way &#8220;final&#8221; is used in Java). Note that such variables
may only be assigned once in the constructor body.</p>
<p>Constructors can call the superclass constructor by using the syntax <tt class="docutils literal"><span class="pre">super()</span></tt>.</p>
<p>Constructors can also invoke other constructors of the same class, by explicitly calling
<tt class="xref docutils literal"><span class="pre">construct()</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The compiler assumes that all constructors are complete, meaning that they initialize
every variable that must be initialized. That means if a constructor calls another constructor,
then when that call returns the compiler presumes that all fields have been initialized, and
any assignments which occur after that point are re-assignments, overwriting values that
were assigned during the call.</p>
<p class="last">This means that once you delegate to another constructor, you cannot assign to any
<tt class="xref docutils literal"><span class="pre">let</span></tt>-defined members afterwards.</p>
</div>
</div>
</div>
<div class="section" id="creating-array-instances">
<span id="index-846"></span><h2>Creating Array Instances<a class="headerlink" href="#creating-array-instances" title="Permalink to this headline">¶</a></h2>
<p>The syntax for constructing a new array instance is the type name, followed
by the dimension of the array in square brackets:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="c">// Allocate an array of 10 rectangles.</span>
<span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="nv">Rectangle</span><span class="p">[</span><span class="mf">10</span><span class="p">];</span>
</pre></div>
</div>
<p>If the element type of the array is a reference (<tt class="xref docutils literal"><span class="pre">class</span></tt>) type, then what is actually
allocated is an array of pointers to that type. If it&#8217;s a value (<tt class="xref docutils literal"><span class="pre">struct</span></tt>) type, then
the array actually contains embedded instances of that type.</p>
<p>The array constructor call is actually implemented as a call to the Array
template class. So the example above is transformed by the compiler into this:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="c">// Allocate an array of 10 rectangles.</span>
<span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="nv">Array</span><span class="p">[</span><span class="nv">Rectangle</span><span class="p">](</span><span class="mf">10</span><span class="p">);</span>
</pre></div>
</div>
<p>If you want to supply a list of initial values for the array, you can either use an array literal
or the static <tt class="xref docutils literal"><span class="pre">of()</span></tt> method of the Array class. Both are equivalent:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="c">// Deduce the type of the array from the list of values</span>
<span class="k">var</span> <span class="nv">x</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="s">&quot;Three&quot;</span><span class="p">];</span>
<span class="k">var</span> <span class="nv">y</span> <span class="o">=</span> <span class="nv">Array</span><span class="o">.</span><span class="nv">of</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">);</span>

<span class="c">// Deduce the type of the array from the list of values and the</span>
<span class="c">// type of the variable being assigned to.</span>
<span class="k">var</span> <span class="nv">x</span><span class="p">:</span><span class="kt">String</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="s">&quot;Three&quot;</span><span class="p">];</span>
<span class="k">var</span> <span class="nv">y</span><span class="p">:</span><span class="kt">int</span><span class="p">[]</span> <span class="o">=</span> <span class="nv">Array</span><span class="o">.</span><span class="nv">of</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">);</span>

<span class="c">// The &#39;of&#39; method also allows you to explicitly specify the array type.</span>
<span class="c">// Most concrete container types in Tart have an &#39;of&#39; method.</span>
<span class="k">var</span> <span class="nv">y</span> <span class="o">=</span> <span class="nv">Array</span><span class="p">[</span><span class="nv">uint32</span><span class="p">]</span><span class="o">.</span><span class="nv">of</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Within Tart expressions, square brackets &#8216;[]&#8217; can have several possible meanings:</p>
<blockquote>
<ul class="simple">
<li>Empty brackets after a type name indicate an array type, such as <tt class="docutils literal"><span class="pre">int[]</span></tt>.</li>
<li>Non-empty brackets after a type name indicate a template argument list, such as
<tt class="docutils literal"><span class="pre">Array[int]</span></tt>.</li>
<li>Non-empty brackets after a variable name indicate an element lookup operation, such
as an array element dereference, or a hash table lookup, for example <tt class="docutils literal"><span class="pre">words[10]</span></tt>.
Any class can support lookup operations using this syntax by declaring an
&#8216;indexer&#8217; method using special syntax.</li>
<li>A bracket that does not follow a symbol name or expression is used to indicate
the beginning of an array literal.</li>
</ul>
</blockquote>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Almost all of the Tart language grammar is <em>context-free</em>, which basically means
that a parser doesn&#8217;t need to understand the semantic meanings of the symbols
in order to correctly parse the source text. This overloading of the square brackets
is the single exception to this rule, which was unavoidable due to the fact that
ASCII only has a limited number of bracketing delimiters - <tt class="docutils literal"><span class="pre">[]</span></tt>, <tt class="docutils literal"><span class="pre">()</span></tt> and <tt class="docutils literal"><span class="pre">{}</span></tt>.
Java and C++ get around this by using <em>angle-brackets</em> - <tt class="docutils literal"><span class="pre">&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;</span></tt> - however, this
causes even greater grammatical ambiguities due to confusion with the less-than
and greater-than operators, and makes the parser even more complicated and less
context-free.</p>
</div>
</div>
</div>
<div class="section" id="interfaces">
<span id="id1"></span><h2>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h2>
<p>Tart supports &#8220;interface inheritance&#8221;, which means that a class can only have one base class,
but can derive from any number of interfaces:</p>
<div class="highlight-tart"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">// A sample base class</span>
<span class="k">class</span> <span class="nc">Widget</span> <span class="k">{</span>
  <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="nv">dc</span><span class="p">:</span><span class="nc">DrawContext</span><span class="p">)</span> <span class="k">{</span>
    <span class="c">// Method body...</span>
  <span class="k">}</span>
<span class="k">}</span>

<span class="c">// An interface</span>
<span class="k">interface</span> <span class="nc">Selectable</span> <span class="k">{</span>
  <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="nv">selected</span><span class="p">:</span><span class="kt">bool</span><span class="p">);</span>
<span class="k">}</span>

<span class="c">// Another interface</span>
<span class="k">interface</span> <span class="nc">HasEventListeners</span> <span class="k">{</span>
  <span class="k">def</span> <span class="nf">addListener</span><span class="p">(</span><span class="nv">handler</span><span class="p">:</span><span class="k">fn</span><span class="p">(</span><span class="nv">e</span><span class="p">:</span><span class="nc">Event</span><span class="p">));</span>
<span class="k">}</span>

<span class="c">// A class that derives from one base class and two interfaces.</span>
<span class="k">class</span> <span class="nc">Window</span> <span class="p">:</span> <span class="nc">Widget</span><span class="p">,</span> <span class="nc">Selectable</span><span class="p">,</span> <span class="nc">HasEventListeners</span> <span class="k">{</span>
  <span class="c">// Override method from base class</span>
  <span class="k">override</span> <span class="nv">draw</span><span class="p">(</span><span class="nv">dc</span><span class="p">:</span><span class="nv">DrawContext</span><span class="p">)</span> <span class="k">{</span>
    <span class="c">// Draw the window...</span>
  <span class="k">}</span>

  <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="nv">selected</span><span class="p">:</span><span class="kt">bool</span><span class="p">)</span> <span class="k">{</span>
    <span class="c">// Implement select</span>
  <span class="k">}</span>

  <span class="k">def</span> <span class="nf">addListener</span><span class="p">(</span><span class="nv">handler</span><span class="p">:</span><span class="k">fn</span><span class="p">(</span><span class="nv">e</span><span class="p">:</span><span class="nc">Event</span><span class="p">))</span> <span class="k">{</span>
    <span class="c">// Implement addListener.</span>
  <span class="k">}</span>
<span class="k">}</span>
</pre></div>
</td></tr></table></div>
<p>Interfaces can only contain a retricted set of definitions:</p>
<blockquote>
<ul class="simple">
<li>Interface methods (methods with no body).</li>
<li>Type definitions</li>
<li>Named constants</li>
</ul>
</blockquote>
<p>A class that derives from an interface type must provide definitions of all of the methods in
the interface, unless that class is declared abstract. Any missing definitions will be flagged
by the compiler.</p>
</div>
<div class="section" id="protocols">
<span id="id2"></span><h2>Protocols<a class="headerlink" href="#protocols" title="Permalink to this headline">¶</a></h2>
<p>A <em>protocol</em> is a kind of abstract type that defines a <em>contract</em> which another type can
support. An example would be a &#8220;HasToString&#8221; protocol:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">protocol</span> <span class="nc">HasToString</span> <span class="k">{</span>
  <span class="k">def</span> <span class="nf">toString</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">;</span>
<span class="k">}</span>
</pre></div>
</div>
<p>What this says is that in order to support the <tt class="docutils literal"><span class="pre">HasToString</span></tt> protocol, a class, interface
or struct must define
a <tt class="xref docutils literal"><span class="pre">toString()</span></tt> method that returns a String. There are two ways that a type can support
a protocol, <em>explicit</em> and <em>implicit</em>. Explicitly supporting a protocol is done by declaring
the protocol in the list of base types:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span> <span class="p">:</span> <span class="nc">HasToString</span> <span class="k">{</span>
  <span class="c">// It would be an error to declare support for HasToString and then</span>
  <span class="c">// fail to define a toString() method.</span>
  <span class="k">def</span> <span class="nf">toString</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">{</span>
    <span class="k">return</span> <span class="s">&quot;Hi there&quot;</span><span class="p">;</span>
  <span class="k">}</span>
<span class="k">}</span>
</pre></div>
</div>
<p>You can also support a protocol implicitly simply by adding the required methods to your type,
without declaring the protocol as a base type. Moreover, this applies even to classes that
know nothing about the protocol - as long as they have the right set of methods, they support
the protocol. So for example, any class that has a <tt class="docutils literal"><span class="pre">toString</span> <span class="pre">-&gt;</span> <span class="pre">String</span></tt> method supports the
<tt class="docutils literal"><span class="pre">HasToString</span></tt> protocol, even if that class were written before <tt class="docutils literal"><span class="pre">HasToString</span></tt> ever existed!</p>
<p>Protocols can only be used as matching constraints - you can&#8217;t declare a variable or a
function parameter whose type is a protocol. (Although, maybe someday...)</p>
<p>Protocols are primarily used in instantiating templates. You can define a template and then
add constraints to its template parameters, such that a parameter can only be bound to a type
that supports the proper protocol.</p>
<p>Note that protocols exist only at compile time, and declararing a protocol as a base type
has no effect on the generated code for that type.</p>
</div>
<div class="section" id="extending-types">
<h2>Extending types<a class="headerlink" href="#extending-types" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><tt class="xref docutils literal"><span class="pre">extend</span></tt> is not implemented in the current release.</p>
</div>
<p>The <tt class="xref docutils literal"><span class="pre">extend</span></tt> keyword allows you to add additional methods to a user-defined type:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="c">/* Add an additional method to the String class. */</span>
<span class="k">extend</span> <span class="nc">String</span> <span class="k">{</span>
  <span class="k">static</span> <span class="k">def</span> <span class="nf">toUpperCase</span><span class="p">()</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>
<span class="k">}</span>
</pre></div>
</div>
<p>Note however, that you can&#8217;t actually change the runtime representation of a type this way. The
reason is simple: The <tt class="xref docutils literal"><span class="pre">extend</span></tt> declaration may not be visible everywhere in the program. If
you extend class <tt class="xref docutils literal"><span class="pre">String</span></tt>, some modules may only see the original, unextended class, while
other modules will see the extended version of the class. In order for all of the code to
interoperate, the runtime implementation of the class must be the same, regardless of the extension.</p>
<p>This means that the extension can only add certain kinds of things to a type, namely:</p>
<ul class="simple">
<li>Static methods or properties.</li>
<li>Final methods or properties.</li>
<li>Inner types and type aliases.</li>
<li>Protocol inheritance declarations.</li>
</ul>
<p>The last is worthy of some note: Since by definition adding a protocol to a class does not affect
the runtime implementation of the class in any way, it is permissible to add a protocol in an
extension. This allows protocols to be added to a class after the fact:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">protocol</span> <span class="nc">Serializable</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>

<span class="c">// Make the string class serializable.</span>
<span class="k">extend</span> <span class="nc">String</span> <span class="p">:</span> <span class="nc">Serializable</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>
</pre></div>
</div>
<p>Extensions follow the same scoping rules as other declarations, meaning that they are only in effect
if the scope in which they are declared is active. For example, we can define an extension inside a
namespace:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>

<span class="k">namespace</span> <span class="nc">JSONUtils</span> <span class="k">{</span>
  <span class="k">extend</span> <span class="nc">Foo</span> <span class="k">{</span>
    <span class="nv">final</span> <span class="k">def</span> <span class="nf">convertToJSon</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>
  <span class="k">}</span>

  <span class="c">// Foo.convertToJSon is visible here</span>
  <span class="k">let</span> <span class="nv">f</span> <span class="o">=</span> <span class="nv">Foo</span><span class="p">();</span>
  <span class="k">let</span> <span class="nv">s</span> <span class="o">=</span> <span class="nv">f</span><span class="o">.</span><span class="nv">convertToJSon</span><span class="p">();</span>
<span class="k">}</span>

<span class="c">// Foo.convertToJSon is no longer visible</span>

<span class="k">import</span> <span class="k">namespace</span> <span class="nc">JSONUtils</span><span class="p">;</span>

<span class="c">// And now it&#39;s visible again.</span>
</pre></div>
</div>
<p>It does not matter whether the extension is visible via the same &#8220;path&#8221; as the original class, so
long as it is in a currently active scope. However, the extension does not apply if the extended
class is hidden by another declaration with the same name:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>
<span class="k">extend</span> <span class="nc">Foo</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>

<span class="k">namespace</span> <span class="nc">JSONUtils</span> <span class="k">{</span>
  <span class="c">/** A different class Foo, unrelated to the extended one. */</span>
  <span class="k">class</span> <span class="nc">Foo</span> <span class="k">{}</span>
<span class="k">}</span>
</pre></div>
</div>
<p>Extensions can be templates if the class that they are extending is also a template. If the original
class is a template and the extension is a specialization of that template, then the extension only
applies when using the specialization:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span><span class="p">[</span><span class="nc">%S</span><span class="p">]</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>

<span class="c">// Only extended for strings</span>
<span class="k">extend</span> <span class="nc">Foo</span><span class="p">[</span><span class="nc">String</span><span class="p">]</span> <span class="k">{</span> <span class="c">/* ...*/</span> <span class="k">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">User-defined types: Composites</a><ul>
<li><a class="reference external" href="#declaring-a-new-class">Declaring a new class</a></li>
<li><a class="reference external" href="#defining-class-members">Defining class members</a><ul>
<li><a class="reference external" href="#member-visibility">Member Visibility</a></li>
<li><a class="reference external" href="#member-variables">Member Variables</a></li>
<li><a class="reference external" href="#properties">Properties</a></li>
<li><a class="reference external" href="#methods">Methods</a></li>
<li><a class="reference external" href="#the-self-parameter">The <tt class="docutils literal"><span class="pre">self</span></tt> parameter</a></li>
</ul>
</li>
<li><a class="reference external" href="#struct-members">Struct members</a></li>
<li><a class="reference external" href="#creating-a-new-class-instance">Creating a new class instance</a></li>
<li><a class="reference external" href="#constructors">Constructors</a><ul>
<li><a class="reference external" href="#default-constructors">Default constructors</a></li>
<li><a class="reference external" href="#constructor-execution">Constructor Execution</a></li>
</ul>
</li>
<li><a class="reference external" href="#creating-array-instances">Creating Array Instances</a></li>
<li><a class="reference external" href="#interfaces">Interfaces</a></li>
<li><a class="reference external" href="#protocols">Protocols</a></li>
<li><a class="reference external" href="#extending-types">Extending types</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="functions.html"
                                  title="previous chapter">Function Type Expressions</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="conversions.html"
                                  title="next chapter">Typecasts and conversions</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/intro/classes.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="conversions.html" title="Typecasts and conversions"
             >next</a> |</li>
        <li class="right" >
          <a href="functions.html" title="Function Type Expressions"
             >previous</a> |</li>
        <li><a href="../index.html">Tart v0.1.1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Introduction to Tart</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008-2011, Talin.
      Last updated on Apr 06, 2011.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.6.
    </div>
  </body>
</html>