<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Classes &mdash; Tart v0.1.1 documentation</title>
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.1',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Tart v0.1.1 documentation" href="../index.html" />
    <link rel="up" title="Introduction to Tart" href="index.html" />
    <link rel="next" title="Typecasts and conversions" href="conversions.html" />
    <link rel="prev" title="Function Type Expressions" href="functions.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="conversions.html" title="Typecasts and conversions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="functions.html" title="Function Type Expressions"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Tart v0.1.1 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Introduction to Tart</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="classes">
<span id="index-235"></span><h1>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h1>
<p>The <tt class="xref docutils literal"><span class="pre">class</span></tt> keyword is one of the four keywords that are used to define a new
aggregate type. The others are <tt class="xref docutils literal"><span class="pre">struct</span></tt>, <tt class="xref docutils literal"><span class="pre">interface</span></tt> and <tt class="xref docutils literal"><span class="pre">protocol</span></tt>.</p>
<ul>
<li><p class="first">A <tt class="xref docutils literal"><span class="pre">class</span></tt> is <em>reference</em> type, meaning it is always passed around by reference.
When you assign a value of class type to a variable, all that gets copied is a pointer to
the object, not the object&#8217;s contents.</p>
</li>
<li><p class="first">A <tt class="xref docutils literal"><span class="pre">struct</span></tt> is a <em>value</em> type. That means that normally when you assign one struct
variable to another, it does a member-wise copy of the entire thing.</p>
</li>
<li><p class="first">An <tt class="xref docutils literal"><span class="pre">interface</span></tt> defines an pure abstract type which can only contain methods, types
and constants. Like Java and C#, Tart does not support multiple inheritance, but does allow
classes to derive from multiple interfaces.</p>
</li>
<li><p class="first">A <tt class="xref docutils literal"><span class="pre">protocol</span></tt> represents a contract which a type may conform to. A class or struct
is said to <em>support</em> the protocol if that class or struct defines all of the method signatures
that are defined by the protocol. Template arguments can be constrained to only match types
which support a specified protocol. Classes may declare explicitly that they support a protocol,
or the support can be determined implicitly.</p>
<p>Protocols will be discussed further in the section on <em class="xref">protocols</em>.</p>
</li>
</ul>
<div class="section" id="declaring-a-new-class">
<span id="index-236"></span><h2>Declaring a new class<a class="headerlink" href="#declaring-a-new-class" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="xref docutils literal"><span class="pre">class</span></tt> keyword defines a new class. Here is a sample of a class definition:</p>
<div class="highlight-tart"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span class="c">// Declare a class. The base class is &#39;ListNode&#39;.</span>
<span class="k">class</span> <span class="nc">Shape</span> <span class="p">:</span> <span class="nc">ListNode</span> <span class="k">{</span>
  <span class="c">// Declare an enumeration</span>
  <span class="k">enum</span> <span class="nc">Style</span> <span class="k">{</span>
    <span class="nv">Filled</span><span class="p">,</span>
    <span class="nv">Hollow</span><span class="p">,</span>
  <span class="k">}</span>

  <span class="c">// Private member variables.</span>
  <span class="k">private</span> <span class="k">{</span>
    <span class="c">// Allow the unit test access to these vars.</span>
    <span class="k">friend</span> <span class="nc">ShapeTest</span><span class="p">;</span>

    <span class="c">// Some variables.</span>
    <span class="k">var</span> <span class="nv">fillStyle</span><span class="p">:</span><span class="nc">Style</span> <span class="o">=</span> <span class="nv">Style</span><span class="o">.</span><span class="nv">Filled</span><span class="p">;</span>
    <span class="k">var</span> <span class="nv">fillColor</span><span class="p">:</span><span class="nc">Color</span><span class="p">;</span>

    <span class="c">// A variable with parameterized type.</span>
    <span class="k">var</span> <span class="nv">children</span><span class="p">:</span><span class="nc">List</span><span class="p">[</span><span class="nv">Shape</span><span class="p">];</span>
  <span class="k">}</span>

  <span class="c">// A member function.</span>
  <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="nv">dc</span><span class="p">:</span><span class="nc">DrawContext</span><span class="p">)</span> <span class="k">{</span>
    <span class="nv">dc</span><span class="o">.</span><span class="nv">setFillStyle</span><span class="p">(</span><span class="nv">fillStyle</span><span class="p">);</span>
    <span class="k">for</span> <span class="nv">child</span> <span class="k">in</span> <span class="nv">children</span> <span class="k">{</span>
      <span class="nv">child</span><span class="o">.</span><span class="nv">draw</span><span class="p">(</span><span class="nv">dc</span><span class="p">);</span>
    <span class="k">}</span>
  <span class="k">}</span>

  <span class="c">// A method with variable number of arguments</span>
  <span class="c">// The &#39;children&#39; argument&#39;s actual type is Shape[]</span>
  <span class="nv">final</span> <span class="k">def</span> <span class="nf">addChildren</span><span class="p">(</span><span class="nv">children</span><span class="p">:</span><span class="nc">Shape</span><span class="gr">...</span><span class="p">)</span> <span class="k">{</span>
    <span class="c">// Explicitly qualified self.children to disambiguate</span>
    <span class="c">// from same-named parameter.</span>
    <span class="bp">self</span><span class="o">.</span><span class="nv">children</span><span class="o">.</span><span class="nv">extend</span><span class="p">(</span><span class="nv">children</span><span class="p">);</span>
  <span class="k">}</span>
<span class="k">}</span>
</pre></div>
</td></tr></table></div>
<p>A couple of things are worth noticing in this example:</p>
<p><strong>Private members:</strong> You can declare a block of variables as <tt class="xref docutils literal"><span class="pre">private</span></tt>, rather than having
to put the word <tt class="xref docutils literal"><span class="pre">private</span></tt> in front of every variable name. Within a <tt class="xref docutils literal"><span class="pre">private</span></tt> or
<tt class="xref docutils literal"><span class="pre">protected</span></tt> block, you can declare <tt class="xref docutils literal"><span class="pre">friend</span></tt> classes that have direct access to
just these class members.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The last point deserves some additional explanation: With C++, you can
only declare a <tt class="xref docutils literal"><span class="pre">friend</span></tt> of an entire class. In Java, you can&#8217;t declare a
<tt class="xref docutils literal"><span class="pre">friend</span></tt> at all. Both of these feature choices cause programmers to expose
too much encapsulated data. In the case of C++, you can&#8217;t expose a private
member without exposing everything. In Java, not having the ability to
expose private data to certain classes causes Java programmers to declare
class members <tt class="docutils literal"><span class="pre">public</span></tt> far more than the would otherwise.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><tt class="docutils literal"><span class="pre">friend</span></tt> is not implemented in the current release.</p>
</div>
<p><strong>Dynamic dispatch is the default</strong>: Like most object-oriented languages (other than C++), all
functions are dynamically overridable (<tt class="docutils literal"><span class="pre">virtual</span></tt> in C++ parlance) unless declared <tt class="docutils literal"><span class="pre">final</span></tt>.</p>
</div>
<div class="section" id="class-members">
<span id="index-237"></span><h2>Class members<a class="headerlink" href="#class-members" title="Permalink to this headline">¶</a></h2>
<p>There is no restriction on the kinds of declarations which can appear in the body of a
<tt class="xref docutils literal"><span class="pre">class</span></tt> or <tt class="xref docutils literal"><span class="pre">struct</span></tt>, but most commonly they will be variable or method
declarations.</p>
<p>Variable declarations can include an optional initialization expression. If present, the
variable will be initialized to this value, instead of the built-in default for that type,
when the class instance is created.</p>
<p>Within a class method, the special variable <tt class="xref docutils literal"><span class="pre">self</span></tt> refers to the current instance.
Unlike Python, you do not need to declare the  <tt class="xref docutils literal"><span class="pre">self</span></tt> variable explicitly.</p>
<p>Instance variables can be referred to directly by name, you do not need to qualify them
with <tt class="xref docutils literal"><span class="pre">self</span></tt> unless you also have a local variable or parameter with the same name.
<tt class="xref docutils literal"><span class="pre">self</span></tt> is often used in constructors:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span><span class="kt">int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span><span class="kt">int</span><span class="p">)</span> <span class="k">{</span>
  <span class="bp">self</span><span class="o">.</span><span class="nv">x</span> <span class="o">=</span> <span class="nv">x</span><span class="p">;</span>
  <span class="bp">self</span><span class="o">.</span><span class="nv">y</span> <span class="o">=</span> <span class="nv">y</span><span class="p">;</span>
<span class="k">}</span>
</pre></div>
</div>
<p>In most cases the <tt class="xref docutils literal"><span class="pre">self</span></tt> parameter works exactly like other, explicitly declared
parameters. The exception to this rule is in <tt class="xref docutils literal"><span class="pre">struct</span></tt> methods. Normally when
the type of a parameter is a <tt class="xref docutils literal"><span class="pre">struct</span></tt>, the value that is passed is a copy of
the struct, however in the case of <tt class="xref docutils literal"><span class="pre">self</span></tt>, what gets passed is a pointer to
the struct. If this were not true, it would be impossible to write methods that modify
struct members, since the method could only modify the temporary copy. Note, however,
that if you assign the <tt class="xref docutils literal"><span class="pre">self</span></tt> parameter to another variable, the variable will
still get a copy.</p>
</div>
<div class="section" id="creating-a-new-class-instance">
<span id="index-238"></span><h2>Creating a new class instance<a class="headerlink" href="#creating-a-new-class-instance" title="Permalink to this headline">¶</a></h2>
<p>The syntax for creating a new class instance is the same as in Python, which is
to call the class as if it were a function:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">var</span> <span class="nv">s</span> <span class="o">=</span> <span class="nv">Rectangle</span><span class="p">(</span><span class="mf">10</span><span class="p">,</span> <span class="mf">10</span><span class="p">,</span> <span class="mf">20</span><span class="p">,</span> <span class="mf">20</span><span class="p">);</span>
</pre></div>
</div>
<p>The creation syntax is the same regardless of whether an object is a value or reference type. If
it&#8217;s a value (<tt class="xref docutils literal"><span class="pre">struct</span></tt>) type, the new object will be constructed in place; If it&#8217;s a
reference (<tt class="xref docutils literal"><span class="pre">class</span></tt>) type, then space for the object will be allocated on the global heap,
and a pointer to the object assigned to the variable.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<div class="last compound">
<p class="compound-first">Value (<tt class="xref docutils literal"><span class="pre">struct</span></tt>) types can never exist on the heap except as instance variables
inside other, reference types. The reason for this is fairly involved, but the short explanation
is this: The garbage collector only deals with reference types. Every reference type has
a special, invisible header field that is used by the garbage collector to track the status
of the object. Structures, integers, floats, tuples, and other value types don&#8217;t have any
invisible fields, they are just &#8216;plain old data&#8217; or &#8216;POD&#8217; types.</p>
<p class="compound-last">Tart also restricts you from having long-lived pointers to these types, because there&#8217;s no
way to track the lifetime of these objects. If you need to keep a long-lived copy of a value
type around, it has to be wrapped inside another object. You can declare a value type as an
instance member of a class, or you can use the provided <tt class="xref docutils literal"><span class="pre">ValueRef</span></tt> or <tt class="xref docutils literal"><span class="pre">MutableRef</span></tt>
helper classes which will automatically wrap (&#8216;auto-box&#8217;) value types when needed.</p>
</div>
</div>
</div>
<div class="section" id="constructors">
<span id="index-239"></span><h2>Constructors<a class="headerlink" href="#constructors" title="Permalink to this headline">¶</a></h2>
<p>A <em>constructor method</em> is responsible for initializing the members of a class instance
when it is created. The constructor method is named <tt class="xref docutils literal"><span class="pre">construct()</span></tt>, and must not declare a
return value.</p>
<p>Here&#8217;s an example of a class with several constructors:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">struct</span> <span class="nc">Rectangle</span> <span class="k">{</span>
  <span class="k">var</span> <span class="nv">x</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
  <span class="k">var</span> <span class="nv">y</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
  <span class="k">var</span> <span class="nv">width</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>
  <span class="k">var</span> <span class="nv">height</span><span class="p">:</span><span class="kt">int</span><span class="p">;</span>

  <span class="c">// Default constructor</span>
  <span class="k">def</span> <span class="nf">construct</span> <span class="k">{</span>
    <span class="nv">x</span> <span class="o">=</span> <span class="nv">y</span> <span class="o">=</span> <span class="nv">width</span> <span class="o">=</span> <span class="nv">height</span> <span class="o">=</span> <span class="mf">0</span><span class="p">;</span>
  <span class="k">}</span>

  <span class="c">// Constructor that takes some arguments</span>
  <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span><span class="kt">int</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span><span class="kt">int</span><span class="p">,</span> <span class="nv">width</span><span class="p">:</span><span class="kt">int</span><span class="p">,</span> <span class="nv">height</span><span class="p">:</span><span class="kt">int</span><span class="p">)</span> <span class="k">{</span>
    <span class="bp">self</span><span class="o">.</span><span class="nv">x</span> <span class="o">=</span> <span class="nv">x</span><span class="p">;</span>
    <span class="bp">self</span><span class="o">.</span><span class="nv">y</span> <span class="o">=</span> <span class="nv">y</span><span class="p">;</span>
    <span class="bp">self</span><span class="o">.</span><span class="nv">width</span> <span class="o">=</span> <span class="nv">width</span><span class="p">;</span>
    <span class="bp">self</span><span class="o">.</span><span class="nv">height</span> <span class="o">=</span> <span class="nv">height</span><span class="p">;</span>
  <span class="k">}</span>

  <span class="c">// Constructor that takes another Rectangle.</span>
  <span class="k">def</span> <span class="nf">construct</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span><span class="nc">Rectangle</span><span class="p">)</span> <span class="k">{</span>
    <span class="nv">x</span> <span class="o">=</span> <span class="nv">from</span><span class="o">.</span><span class="nv">x</span><span class="p">;</span>
    <span class="nv">y</span> <span class="o">=</span> <span class="nv">from</span><span class="o">.</span><span class="nv">y</span><span class="p">;</span>
    <span class="nv">width</span> <span class="o">=</span> <span class="nv">from</span><span class="o">.</span><span class="nv">width</span><span class="p">;</span>
    <span class="nv">height</span> <span class="o">=</span> <span class="nv">from</span><span class="o">.</span><span class="nv">height</span><span class="p">;</span>
  <span class="k">}</span>
<span class="k">}</span>
</pre></div>
</div>
<p>When you create a new instance of a type by calling the type as a function, the compiler attempts to
locate a constructor method having the same signature as the calling arguments. This search
happens in several steps:</p>
<ul>
<li><p class="first">First, the compiler looks for a constructor method named <tt class="xref docutils literal"><span class="pre">construct()</span></tt> having the
appropriate signature.</p>
<p>If the class has one or more constructor methods, but none of them match the input arguments,
then the result is an error. Similarly, if there are constructors but none of them are accessible
to the caller, then this is also an error.</p>
</li>
<li><p class="first">If the class has no constructor methods at all, then the compiler will look for a static
member function called <tt class="xref docutils literal"><span class="pre">create()</span></tt> and call it instead.</p>
<p>The <tt class="xref docutils literal"><span class="pre">create()</span></tt> function is not required to return a newly created object every time - it
can return the same object as a previous call. It is also not required to return an object whose
type is the same as the class, but it should at least be a subtype.</p>
<p>The <tt class="xref docutils literal"><span class="pre">create()</span></tt> function is responsible for both allocating the memory for the object and
initializing it completely.</p>
<p>The <tt class="xref docutils literal"><span class="pre">create()</span></tt> function is often used to implement a custom allocation strategy for a type.
For example, the <tt class="xref docutils literal"><span class="pre">String</span></tt> class uses the <tt class="xref docutils literal"><span class="pre">create()</span></tt> function to allow string objects
to be variably sized - so that both the fixed-length header part and the variable-length
character array can be combined into a single memory allocation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is nothing special about this function other than the fact that the compiler
calls it automatically.</p>
</div>
</li>
<li><p class="first">If the class has no constructors, and no <tt class="xref docutils literal"><span class="pre">create()</span></tt> function, then the compiler will attempt
to synthesize a default constructor.</p>
</li>
</ul>
<p id="index-241">Any member variable which is not initialized by the constructor will be set to
its default value. If the default value for the member variable has not been
specified, then it uses the default value for that type.</p>
</div>
<div class="section" id="default-constructors">
<span id="index-242"></span><h2>Default constructors<a class="headerlink" href="#default-constructors" title="Permalink to this headline">¶</a></h2>
<p>If the object has no <tt class="xref docutils literal"><span class="pre">construct()</span></tt> method and no <tt class="xref docutils literal"><span class="pre">create()</span></tt> method, then the compiler
will attempt to create a default constructor. The default constructor takes no arguments,
and will initialize every field to its default value. If any fields cannot be initialized
to a default, then the compiler will emit an error.</p>
</div>
<div class="section" id="constructor-execution">
<span id="index-243"></span><h2>Constructor Execution<a class="headerlink" href="#constructor-execution" title="Permalink to this headline">¶</a></h2>
<p>The compiler will attempt to ensure that all member fields are initialized during the execution of
the constructor. Fields which have no defaults must be assigned in the constructor, whereas fields
which do have defaults (either explicitly specified or implicit based on the type) may not be.
If the compiler detects that any field is not fully initialized, then it will report an error.</p>
<p>Member variables that are declared with <tt class="xref docutils literal"><span class="pre">let</span></tt> cannot be assigned a value after the
constructor has finished execution. In most cases, these kinds of variables will be constants
anyway, meaning that their values are fixed at compile time. However, Tart also allows
<tt class="xref docutils literal"><span class="pre">let</span></tt> variables to be assigned in the constructor, in which case they are constant for
the life of that instance (similar to the way &#8220;final&#8221; is used in Java). Note that such variables
may only be assigned once in the constructor body.</p>
<p>Constructors can call the superclass constructor by using the syntax <tt class="docutils literal"><span class="pre">super()</span></tt>.</p>
<p>Constructors can also invoke other constructors of the same class, by explicitly calling
<tt class="xref docutils literal"><span class="pre">construct()</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The compiler assumes that all constructors are complete, meaning that they initialize
every variable that must be initialized. That means if a constructor calls another constructor,
then when that call returns the compiler presumes that all fields have been initialized, and
any assignments which occur after that point are re-assignments, overwriting values that
were assigned during the call.</p>
<p class="last">This means that once you delegate to another constructor, you cannot assign to any
<tt class="xref docutils literal"><span class="pre">let</span></tt>-defined members afterwards.</p>
</div>
</div>
<div class="section" id="array-constructors">
<span id="index-244"></span><h2>Array constructors<a class="headerlink" href="#array-constructors" title="Permalink to this headline">¶</a></h2>
<p>The syntax for constructing a new array instance is the type name, followed
by the dimension of the array in square brackets:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="c">// Allocate an array of 10 rectangles.</span>
<span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="nv">Rectangle</span><span class="p">[</span><span class="mf">10</span><span class="p">];</span>
</pre></div>
</div>
<p>If the element type of the array is a reference (<tt class="xref docutils literal"><span class="pre">class</span></tt>) type, then what is actually
allocated is an array of pointers to that type. If it&#8217;s a value (<tt class="xref docutils literal"><span class="pre">struct</span></tt>) type, then
the array actually contains embedded instances of that type.</p>
<p>The array constructor call is actually implemented as a call to the Array
template class. So the example above is transformed by the compiler into this:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="c">// Allocate an array of 10 rectangles.</span>
<span class="k">let</span> <span class="nv">a</span> <span class="o">=</span> <span class="nv">Array</span><span class="p">[</span><span class="nv">Rectangle</span><span class="p">](</span><span class="mf">10</span><span class="p">);</span>
</pre></div>
</div>
<p>If you want to supply a list of initial values for the array, you can either use an array literal
or the static <tt class="xref docutils literal"><span class="pre">of()</span></tt> method of the Array class. Both are equivalent:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="c">// Deduce the type of the array from the list of values</span>
<span class="k">var</span> <span class="nv">x</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="s">&quot;Three&quot;</span><span class="p">];</span>
<span class="k">var</span> <span class="nv">y</span> <span class="o">=</span> <span class="nv">Array</span><span class="o">.</span><span class="nv">of</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">);</span>

<span class="c">// Deduce the type of the array from the list of values and the</span>
<span class="c">// type of the variable being assigned to.</span>
<span class="k">var</span> <span class="nv">x</span><span class="p">:</span><span class="kt">String</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;One&quot;</span><span class="p">,</span> <span class="s">&quot;Two&quot;</span><span class="p">,</span> <span class="s">&quot;Three&quot;</span><span class="p">];</span>
<span class="k">var</span> <span class="nv">y</span><span class="p">:</span><span class="kt">int</span><span class="p">[]</span> <span class="o">=</span> <span class="nv">Array</span><span class="o">.</span><span class="nv">of</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">);</span>

<span class="c">// The &#39;of&#39; method also allows you to explicitly specify the array type.</span>
<span class="c">// Most concrete container types in Tart have an &#39;of&#39; method.</span>
<span class="k">var</span> <span class="nv">y</span> <span class="o">=</span> <span class="nv">Array</span><span class="p">[</span><span class="nv">uint32</span><span class="p">]</span><span class="o">.</span><span class="nv">of</span><span class="p">(</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Within Tart expressions, square brackets &#8216;[]&#8217; can have several possible meanings:</p>
<blockquote>
<ul class="simple">
<li>Empty brackets after a type name indicate an array type, such as <tt class="docutils literal"><span class="pre">int[]</span></tt>.</li>
<li>Non-empty brackets after a type name indicate a template argument list, such as
<tt class="docutils literal"><span class="pre">Array[int]</span></tt>.</li>
<li>Non-empty brackets after a variable name indicate an element lookup operation, such
as an array element dereference, or a hash table lookup, for example <tt class="docutils literal"><span class="pre">words[10]</span></tt>.
Any class can support lookup operations using this syntax by declaring an
&#8216;indexer&#8217; method using special syntax.</li>
<li>A bracket that does not follow a symbol name or expression is used to indicate
the beginning of an array literal.</li>
</ul>
</blockquote>
<div class="last admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Almost all of the Tart language grammar is <em>context-free</em>, which basically means
that a parser doesn&#8217;t need to understand the semantic meanings of the symbols
in order to correctly parse the source text. This overloading of the square brackets
is the single exception to this rule, which was unavoidable due to the fact that
ASCII only has a limited number of bracketing delimiters - <tt class="docutils literal"><span class="pre">[]</span></tt>, <tt class="docutils literal"><span class="pre">()</span></tt> and <tt class="docutils literal"><span class="pre">{}</span></tt>.
Java and C++ get around this by using <em>angle-brackets</em> - <tt class="docutils literal"><span class="pre">&lt;</span></tt> and <tt class="docutils literal"><span class="pre">&gt;</span></tt> - however, this
causes even greater grammatical ambiguities due to confusion with the less-than
and greater-than operators, and makes the parser even more complicated and less
context-free.</p>
</div>
</div>
</div>
<div class="section" id="extending-types">
<h2>Extending types<a class="headerlink" href="#extending-types" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><tt class="xref docutils literal"><span class="pre">extend</span></tt> is not implemented in the current release.</p>
</div>
<p>The <tt class="xref docutils literal"><span class="pre">extend</span></tt> keyword allows you to add additional methods to a user-defined type:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="c">/* Add an additional method to the String class. */</span>
<span class="k">extend</span> <span class="nc">String</span> <span class="k">{</span>
  <span class="k">static</span> <span class="k">def</span> <span class="nf">toUpperCase</span><span class="p">()</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>
<span class="k">}</span>
</pre></div>
</div>
<p>Note however, that you can&#8217;t actually change the runtime representation of a type this way. The
reason is simple: The <tt class="xref docutils literal"><span class="pre">extend</span></tt> declaration may not be visible everywhere in the program. If
you extend class <tt class="xref docutils literal"><span class="pre">String</span></tt>, some modules may only see the original, unextended class, while
other modules will see the extended version of the class. In order for all of the code to
interoperate, the runtime implementation of the class must be the same, regardless of the extension.</p>
<p>This means that the extension can only add certain kinds of things to a type, namely:</p>
<ul class="simple">
<li>Static methods or properties.</li>
<li>Final methods or properties.</li>
<li>Inner types and type aliases.</li>
<li>Protocol inheritance declarations.</li>
</ul>
<p>The last is worthy of some note: Since by definition adding a protocol to a class does not affect
the runtime implementation of the class in any way, it is permissible to add a protocol in an
extension. This allows protocols to be added to a class after the fact:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">protocol</span> <span class="nc">Serializable</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>

<span class="c">// Make the string class serializable.</span>
<span class="k">extend</span> <span class="nc">String</span> <span class="p">:</span> <span class="nc">Serializable</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>
</pre></div>
</div>
<p>Extensions follow the same scoping rules as other declarations, meaning that they are only in effect
if the scope in which they are declared is active. For example, we can define an extension inside a
namespace:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>

<span class="k">namespace</span> <span class="nc">JSONUtils</span> <span class="k">{</span>
  <span class="k">extend</span> <span class="nc">Foo</span> <span class="k">{</span>
    <span class="nv">final</span> <span class="k">def</span> <span class="nf">convertToJSon</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>
  <span class="k">}</span>

  <span class="c">// Foo.convertToJSon is visible here</span>
  <span class="k">let</span> <span class="nv">f</span> <span class="o">=</span> <span class="nv">Foo</span><span class="p">();</span>
  <span class="k">let</span> <span class="nv">s</span> <span class="o">=</span> <span class="nv">f</span><span class="o">.</span><span class="nv">convertToJSon</span><span class="p">();</span>
<span class="k">}</span>

<span class="c">// Foo.convertToJSon is no longer visible</span>

<span class="k">import</span> <span class="k">namespace</span> <span class="nc">JSONUtils</span><span class="p">;</span>

<span class="c">// And now it&#39;s visible again.</span>
</pre></div>
</div>
<p>It does not matter whether the extension is visible via the same &#8220;path&#8221; as the original class, so
long as it is in a currently active scope. However, the extension does not apply if the extended
class is hidden by another declaration with the same name:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>
<span class="k">extend</span> <span class="nc">Foo</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>

<span class="k">namespace</span> <span class="nc">JSONUtils</span> <span class="k">{</span>
  <span class="c">/** A different class Foo, unrelated to the extended one. */</span>
  <span class="k">class</span> <span class="nc">Foo</span> <span class="k">{}</span>
<span class="k">}</span>
</pre></div>
</div>
<p>Extensions can be templates if the class that they are extending is also a template. If the original
class is a template and the extension is a specialization of that template, then the extension only
applies when using the specialization:</p>
<div class="highlight-tart"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span><span class="p">[</span><span class="nc">%S</span><span class="p">]</span> <span class="k">{</span> <span class="c">/* ... */</span> <span class="k">}</span>

<span class="c">// Only extended for strings</span>
<span class="k">extend</span> <span class="nc">Foo</span><span class="p">[</span><span class="nc">String</span><span class="p">]</span> <span class="k">{</span> <span class="c">/* ...*/</span> <span class="k">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h3><a href="../index.html">Table Of Contents</a></h3>
            <ul>
<li><a class="reference external" href="#">Classes</a><ul>
<li><a class="reference external" href="#declaring-a-new-class">Declaring a new class</a></li>
<li><a class="reference external" href="#class-members">Class members</a></li>
<li><a class="reference external" href="#creating-a-new-class-instance">Creating a new class instance</a></li>
<li><a class="reference external" href="#constructors">Constructors</a></li>
<li><a class="reference external" href="#default-constructors">Default constructors</a></li>
<li><a class="reference external" href="#constructor-execution">Constructor Execution</a></li>
<li><a class="reference external" href="#array-constructors">Array constructors</a></li>
<li><a class="reference external" href="#extending-types">Extending types</a></li>
</ul>
</li>
</ul>

            <h4>Previous topic</h4>
            <p class="topless"><a href="functions.html"
                                  title="previous chapter">Function Type Expressions</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="conversions.html"
                                  title="next chapter">Typecasts and conversions</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="../_sources/intro/classes.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="../search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="conversions.html" title="Typecasts and conversions"
             >next</a> |</li>
        <li class="right" >
          <a href="functions.html" title="Function Type Expressions"
             >previous</a> |</li>
        <li><a href="../index.html">Tart v0.1.1 documentation</a> &raquo;</li>
          <li><a href="index.html" >Introduction to Tart</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2008-2011, Talin.
      Last updated on Mar 29, 2011.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.6.
    </div>
  </body>
</html>